import{gameData}from"./game_data.js";class Renderer{constructor(t,e,i,s,a,r,n){this.canvas=t,this.fontTextureWidth=null,this.fontTextureHeight=null,this.palette=e,this.charBitmaps=i,this.spriteSize=s,this.numberOfCols=a,this.scale=r,this.spriteTrueSize=s*r,this.fontCharMap=null,this.gl=t.getContext("webgl2"),this.gl||console.error("WebGL2 not supported"),this.drawQueue=[],this.initGL(),this.textureMap={sprite:this.prepTexture(),font:this.prepTexture({width:Object.keys(this.charBitmaps).length*this.spriteSize,height:this.palette.length*this.spriteSize}),tileMap:this.prepTexture({width:128*this.spriteSize,height:64*this.spriteSize})},this.offscreenTexture=null,this.maxSprites=2e3,this.vertexSize=24,this.spriteBatch=new Float32Array(this.maxSprites*this.vertexSize),this.spriteSheetCanvas=null,this.tileMapCanvas=null,this.tileMap=n,this.spriteData=[],this.loadFontTextureFromBitmaps()}initGL(){const t=this.gl;t.enable(t.BLEND),t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA);this.program=this.createShaderProgram("#version 300 es\n            precision mediump float;\n            in vec2 position;\n            in vec2 texcoord;\n            out vec2 v_texcoord;\n            void main() {\n                gl_Position = vec4(position, 0.0, 1.0);\n                v_texcoord = texcoord;\n            }\n        ","#version 300 es\n            precision mediump float;\n            in vec2 v_texcoord;\n            out vec4 outColor;\n            uniform sampler2D u_texture;\n            void main() {\n                outColor = texture(u_texture, v_texcoord);\n            }\n        "),t.useProgram(this.program),this.vertexBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),this.positionLoc=t.getAttribLocation(this.program,"position"),t.enableVertexAttribArray(this.positionLoc),t.vertexAttribPointer(this.positionLoc,2,t.FLOAT,!1,16,0),this.texcoordLoc=t.getAttribLocation(this.program,"texcoord"),t.enableVertexAttribArray(this.texcoordLoc),t.vertexAttribPointer(this.texcoordLoc,2,t.FLOAT,!1,16,8),this.uTexture=t.getUniformLocation(this.program,"u_texture"),t.uniform1i(this.uTexture,0)}prepTexture(t={width:this.canvas.width,height:this.canvas.width}){const e=this.gl,i=e.createTexture();return e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,i),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,t.width,t.height,0,e.RGBA,e.UNSIGNED_BYTE,null),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,null),i}createShaderProgram(t,e){const i=this.gl;function s(t,e,i){const s=t.createShader(e);return t.shaderSource(s,i),t.compileShader(s),t.getShaderParameter(s,t.COMPILE_STATUS)?s:(console.error(t.getShaderInfoLog(s)),t.deleteShader(s),null)}const a=s(i,i.VERTEX_SHADER,t),r=s(i,i.FRAGMENT_SHADER,e),n=i.createProgram();return i.attachShader(n,a),i.attachShader(n,r),i.linkProgram(n),i.getProgramParameter(n,i.LINK_STATUS)||console.error(i.getProgramInfoLog(n)),n}setPalette(t){this.palette=t}loadSpriteDataToTexture(t){this.spriteData=t;const e=document.createElement("canvas");e.width=this.canvas.width,e.height=this.canvas.width;const i=e.getContext("2d"),s=i.createImageData(this.canvas.width,this.canvas.width),a=s.data;for(let i=0;i<t.length;i++){const s=i%this.numberOfCols*this.spriteTrueSize,r=Math.floor(i/this.numberOfCols)*this.spriteTrueSize;for(let n=0;n<this.spriteSize;n++)for(let h=0;h<this.spriteSize;h++){const o=this.palette[t[i][n][h]]||[0,0,0,0];for(let t=0;t<this.scale;t++)for(let i=0;i<this.scale;i++){const l=s+h*this.scale+i,c=4*((r+n*this.scale+t)*e.width+l);a[c]=255*o[0],a[c+1]=255*o[1],a[c+2]=255*o[2],a[c+3]=o.length>3?o[3]:255}}}i.putImageData(s,0,0),this.spriteSheetCanvas=e;const r=this.gl;r.activeTexture(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,this.textureMap.sprite),r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,e),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.NEAREST),r.activeTexture(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,null)}loadTilemapDataToTexture(t){const e=document.createElement("canvas");e.width=128*this.spriteSize,e.height=64*this.spriteSize;const i=e.getContext("2d");if(!this.spriteSheetCanvas)return void console.error("spriteSheetCanvas saknas. Kör loadSpriteDataToTexture först.");Math.floor(this.spriteSheetCanvas.width/this.spriteTrueSize);for(let e=0;e<64;e++)for(let s=0;s<128;s++){const a=t[e][s];if(null==a||255===a)continue;const r=a%this.numberOfCols*this.spriteTrueSize,n=Math.floor(a/this.numberOfCols)*this.spriteTrueSize;i.drawImage(this.spriteSheetCanvas,r,n,this.spriteTrueSize,this.spriteTrueSize,s*this.spriteSize,e*this.spriteSize,this.spriteSize,this.spriteSize)}const s=this.gl;s.activeTexture(s.TEXTURE0),s.bindTexture(s.TEXTURE_2D,this.textureMap.tileMap),s.texImage2D(s.TEXTURE_2D,0,s.RGBA,s.RGBA,s.UNSIGNED_BYTE,e),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MIN_FILTER,s.NEAREST),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MAG_FILTER,s.NEAREST),s.bindTexture(s.TEXTURE_2D,null),this.tileMapCanvas=e}loadFontTextureFromBitmaps(){const t=this.charBitmaps,e=this.palette,i=Object.keys(t),s=i.length,a=e.length,r=document.createElement("canvas");r.width=8*s,r.height=8*a,this.fontTextureWidth=r.width,this.fontTextureHeight=r.height;const n=r.getContext("2d"),h=n.createImageData(r.width,r.height),o=h.data;for(let n=0;n<s;n++){const s=t[i[n]];for(let t=0;t<a;t++){const i=e[t];for(let e=0;e<8;e++)for(let a=0;a<8;a++){const h=s[e][a],l=8*n+a,c=4*((8*t+e)*r.width+l);o[c]=255*i[0]*h,o[c+1]=255*i[1]*h,o[c+2]=255*i[2]*h,o[c+3]=h?255:0}}}n.putImageData(h,0,0);const l=this.gl;l.activeTexture(l.TEXTURE0),l.bindTexture(l.TEXTURE_2D,this.textureMap.font),l.texImage2D(l.TEXTURE_2D,0,l.RGBA,l.RGBA,l.UNSIGNED_BYTE,r),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_MIN_FILTER,l.NEAREST),l.texParameteri(l.TEXTURE_2D,l.TEXTURE_MAG_FILTER,l.NEAREST),l.activeTexture(l.TEXTURE0),l.activeTexture(l.TEXTURE0),l.bindTexture(l.TEXTURE_2D,null),this.fontCharMap=Object.fromEntries(i.map((t,e)=>[t,e]))}clearScreen(t=[0,0,0]){this.drawQueue=[];const e=this.gl;e.clearColor(t[0],t[1],t[2],1),e.clear(e.COLOR_BUFFER_BIT)}drawRect(t,e,i,s,a){this.drawQueue.push({type:"rect",x:t,y:e,width:i,height:s,color:a})}drawCircle(t,e,i,s){this.drawQueue.push({type:"circle",x:t,y:e,radius:i,color:s})}drawLinedRect(t,e,i,s,a){this.drawRect(t,e,i,this.scale,a),this.drawRect(t,e,this.scale,s,a),this.drawRect(t+i-this.scale,e,this.scale,s,a),this.drawRect(t,e+s-this.scale,i,this.scale,a)}drawSprite(t,e,i,s={scaleX:1,scaleY:1,flipX:!1,flipY:!1}){let a=t%this.numberOfCols*this.spriteTrueSize/this.canvas.width,r=Math.floor(t/this.numberOfCols)*this.spriteTrueSize/this.canvas.width,n=this.spriteTrueSize/this.canvas.width;e*=this.scale,i*=this.scale,this.drawQueue.push({type:"sprite",id:t,x:e,y:i,spriteX:a,spriteY:r,spriteSize:n,options:s})}drawText(t,e,i,s=7,a={}){e*=this.scale,i*=this.scale,t=t.toString();const r=a.scale??1,n=Math.round((a.spacing??this.scale*this.scale/1.6)*Math.max(.1,r)),h=t.toUpperCase();for(let t=0;t<h.length;t++){const o=h[t],l=this.fontCharMap?.[o];if(void 0===l)continue;const c=s,p=l*this.spriteSize/this.fontTextureWidth,d=c*this.spriteSize/this.fontTextureHeight,u=this.spriteSize/this.fontTextureWidth,m=this.spriteSize/this.fontTextureHeight;this.drawQueue.push({type:"font",x:e+t*(this.spriteSize*r+n),y:i,spriteX:p,spriteY:d,spriteWidth:u,spriteHeight:m,options:a})}}drawTilemap(t,e,i,s,a,r,n={}){this.drawQueue.push({type:"tilemap",cx:t,cy:e,mx:i,my:s,mw:a,mh:r,scale:n.scale??this.scale??1})}flushSpriteBatchRange(t,e){const i=this.gl;let s=0;for(let a=t;a<e;a++){const t=this.drawQueue[a];if(!t||"sprite"!==t.type)continue;const{scaleX:e=1,scaleY:r=1,flipX:n=!1,flipY:h=!1}=t.options??{},o=e*(n?-1:1),l=r*(h?-1:1),c=Math.floor(t.x)/(this.canvas.width/2)-1,p=1-Math.floor(t.y)/(this.canvas.width/2),d=this.spriteTrueSize*e/(this.canvas.width/2),u=this.spriteTrueSize*r/(this.canvas.width/2);let m=t.spriteX,f=t.spriteY,T=t.spriteX+t.spriteSize,x=t.spriteY+t.spriteSize;o<0&&([m,T]=[T,m]),l<0&&([f,x]=[x,f]);const E=6*s*4,g=this.spriteBatch,S=[[c,p,m,f],[c+d,p,T,f],[c,p-u,m,x],[c,p-u,m,x],[c+d,p,T,f],[c+d,p-u,T,x]];for(let t=0;t<6;t++){const e=E+4*t;g[e+0]=S[t][0],g[e+1]=S[t][1],g[e+2]=S[t][2],g[e+3]=S[t][3]}s++,s>=this.maxSprites&&(i.activeTexture(i.TEXTURE0),i.bindTexture(i.TEXTURE_2D,this.textureMap.sprite),i.bindBuffer(i.ARRAY_BUFFER,this.vertexBuffer),i.bufferData(i.ARRAY_BUFFER,this.spriteBatch.subarray(0,6*s*4),i.DYNAMIC_DRAW),i.drawArrays(i.TRIANGLES,0,6*s),s=0)}return s>0&&(i.activeTexture(i.TEXTURE0),i.bindTexture(i.TEXTURE_2D,this.textureMap.sprite),i.bindBuffer(i.ARRAY_BUFFER,this.vertexBuffer),i.bufferData(i.ARRAY_BUFFER,this.spriteBatch.subarray(0,6*s*4),i.DYNAMIC_DRAW),i.drawArrays(i.TRIANGLES,0,6*s)),e}renderTilemap(t){const e=this.gl,{cx:i,cy:s,mx:a,my:r,mw:n,mh:h,scale:o=this.scale}=t,l=128*this.spriteSize,c=64*this.spriteSize,p=.5/l,d=.5/c,u=(a+p)/l,m=(r+d)/c,f=(a+n-p)/l,T=(r+h-d)/c,x=this.canvas.width/2,E=this.canvas.height/2,g=i/x-1,S=1-s/E,R=g+n*o/x,w=S-h*o/E,v=new Float32Array([g,S,u,m,R,S,f,m,g,w,u,T,g,w,u,T,R,S,f,m,R,w,f,T]);e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,this.textureMap.tileMap),e.bindBuffer(e.ARRAY_BUFFER,this.vertexBuffer),e.bufferData(e.ARRAY_BUFFER,v,e.STATIC_DRAW),e.drawArrays(e.TRIANGLES,0,6)}clearDrawQueue(){this.drawQueue=[]}drawFont(t){const{scale:e=1,flipX:i=!1,flipY:s=!1}=t.options??{},a=this.canvas.width/2,r=t.x/a-1,n=1-t.y/a,h=r+this.spriteTrueSize*e*(i?-1:1)/a,o=n-this.spriteTrueSize*e*(s?-1:1)/a;let l=t.spriteX,c=t.spriteY,p=l+t.spriteWidth,d=c+t.spriteHeight;i&&([l,p]=[p,l]),s&&([c,d]=[d,c]);const u=new Float32Array([r,n,l,c,h,n,p,c,r,o,l,d,r,o,l,d,h,n,p,c,h,o,p,d]),m=this.gl;m.activeTexture(m.TEXTURE0),m.bindTexture(m.TEXTURE_2D,this.textureMap.font),m.bindBuffer(m.ARRAY_BUFFER,this.vertexBuffer),m.bufferData(m.ARRAY_BUFFER,u,m.STATIC_DRAW),m.drawArrays(m.TRIANGLES,0,6)}drawRectImmediate(t){let e=t.width/(this.canvas.width/2),i=t.height/(this.canvas.width/2),s=1+t.x/(this.canvas.width/2)-1,a=1-t.y/(this.canvas.width/2)+1-i,r=t.color;const n=this.gl;n.enable(n.SCISSOR_TEST),n.scissor(s*(this.canvas.width/2),a*(this.canvas.width/2),e*(this.canvas.width/2),i*(this.canvas.width/2)),n.clearColor(r[0],r[1],r[2],r[3]||1),n.clear(n.COLOR_BUFFER_BIT),n.disable(n.SCISSOR_TEST)}drawEvenCircleFill(t){const{x:e,y:i,radius:s,color:a}=t,r=this.scale;if(1===s)return void this.drawRectImmediate({x:(e-s)*r,y:(i-s)*r,width:2*r,height:2*r,color:a});const n=s*s;for(let t=-s;t<s;t++){const s=t+.5,h=n-s*s-1;if(h<=0)continue;const o=Math.max(0,Math.round(Math.sqrt(h))),l=2*o;l<=0||this.drawRectImmediate({x:(e-o)*r,y:(i+t)*r,width:l*r,height:r,color:a})}}drawSpriteWithSingleColor(t,e,i,s,{scale:a=1,flipX:r=!1,flipY:n=!1}={}){this.gl;const h=this.spriteSize,o=e*this.scale,l=i*this.scale,c=this.spriteData[t];for(let t=0;t<h;t++)for(let e=0;e<h;e++){if(255===c[t][e])continue;let i=n?h-1-t:t;const p=o+(r?h-1-e:e)*this.scale*a,d=l+i*this.scale*a;this.drawQueue.push({type:"rect",x:p,y:d,width:this.scale*a,height:this.scale*a,color:s})}}drawPixel(t,e,i){const s=this.gl,a=this.scale,r=t*this.canvas.width/2,n=e*this.canvas.height/2;s.enable(s.SCISSOR_TEST),s.scissor(r,n,a,a),s.clearColor(i[0],i[1],i[2],i[3]||1),s.clear(s.COLOR_BUFFER_BIT),s.disable(s.SCISSOR_TEST)}drawTilemapTexture(t,e,i=1){const s=this.gl,a=128*i,r=128*i,n=this.canvas.width/2,h=t/n-1,o=1-e/n,l=h+a/n,c=o-r/n,p=new Float32Array([h,o,0,0,l,o,1,0,h,c,0,1,h,c,0,1,l,o,1,0,l,c,1,1]);s.activeTexture(s.TEXTURE0),s.bindTexture(s.TEXTURE_2D,this.offscreenTexture),s.bindBuffer(s.ARRAY_BUFFER,this.vertexBuffer),s.bufferData(s.ARRAY_BUFFER,p,s.STATIC_DRAW),s.drawArrays(s.TRIANGLES,0,6)}render(){const t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,null),t.viewport(0,0,this.canvas.width,this.canvas.height),t.clear(t.COLOR_BUFFER_BIT),t.useProgram(this.program),t.bindBuffer(t.ARRAY_BUFFER,this.vertexBuffer),t.enableVertexAttribArray(this.positionLoc),t.vertexAttribPointer(this.positionLoc,2,t.FLOAT,!1,16,0),t.enableVertexAttribArray(this.texcoordLoc),t.vertexAttribPointer(this.texcoordLoc,2,t.FLOAT,!1,16,8);let e=-1;const i=t=>{-1!==e&&(this.flushSpriteBatchRange(e,t),e=-1)};for(let t=0;t<this.drawQueue.length;t++){const s=this.drawQueue[t];s&&("sprite"!==s.type?(i(t),"font"===s.type&&this.drawFont(s),"rect"===s.type&&this.drawRectImmediate(s),"circle"===s.type&&this.drawEvenCircleFill(s),"tilemap"===s.type&&this.renderTilemap(s)):-1===e&&(e=t))}i(this.drawQueue.length),this.clearDrawQueue()}}class GameParser{constructor(t,e,i,s,a,r,n){this.userCode=t,this.renderer=e,this.gameFunctions={_init:()=>{},_update:()=>{},_draw:()=>{}},this.inputState=null,this.keyboardState=null,this.gamepadState=null,this.colorPalette=i,this.scale=s,this.inputMap=r,this.fixedDelta=1e3/60,this.lastTime=performance.now(),this.fpsAccumulator=0,this.alpha=null,this.collisionLayer=n||Array.from({length:64},()=>Array(128).fill(0)),this.collisionHelper=new CollisionHelper(this.collisionLayer,a,this.scale),this.gamepadMap={buttons:{},axes:{}},this.sceneObjects=[],this.camera={x:0,y:0,width:e.width,height:e.height,scale:1},this.sandbox={Math:Math,console:console,log:(...t)=>console.log("[Game]:",...t),print:(t,e=0,i=0,s=7,a=1)=>this.renderer.drawText(t,e,i,s,{scale:a}),cls:(t=0)=>this.renderer.clearScreen(this.colorPalette[t]),spr:(t,e,i,s=0,a={scale:1,flipX:!1,flipY:!1})=>this.renderer.drawSpriteWithSingleColor(t,e,i,this.colorPalette[s],{scaleX:a.scale,scaleY:a.scale,flipX:a.flipX,flipY:a.flipY}),map:(t,e,i,s,a,r)=>this.renderer.drawTilemap(t,e,i,s,a,r),cam:(t,e,i=1)=>this.drawCamera(t,e,i),rect:(t,e,i,s,a=7)=>this.renderer.drawRect(t*this.scale,e*this.scale,i*this.scale,s*this.scale,this.colorPalette[a]),collide:(t,e)=>this.collisionHelper.isPointSolid(t,e),collide_circle:(t,e,i)=>this.collisionHelper.isCircleColliding(t,e,i),collide_box:(t,e,i,s,a=null,r=null)=>this.collisionHelper.isBoxColliding(t,e,i,s,{map:r,mask:a}),collide_boxes:(t,e,i,s,a,r,n,h)=>this.collisionHelper.aabbOverlap(t,e,i,s,a,r,n,h),check_half_tile:(t,e,i,s,a,r,n=this.map)=>this.collisionHelper.checkHalfTile(t,e,i,s,a,r,n),make_collider:(t=null,e=null)=>new CollisionHelper(t||this.collisionLayer,e,this.scale),circ:(t,e,i,s=7)=>this.renderer.drawCircle(t,e,i,this.colorPalette[s]),btn:t=>!(!this.keyboardState?.[t]&&!this.gamepadState?.[t]),btn_pressed:t=>{const e=!!this.keyboardState?.[t],i=!!this.keyboardPrevState?.[t],s=!!this.gamepadState?.[t],a=!!this.gamepadPrevState?.[t];return e&&!i||s&&!a},btn_released:t=>{const e=!!this.keyboardState?.[t],i=!!this.keyboardPrevState?.[t],s=!!this.gamepadState?.[t],a=!!this.gamepadPrevState?.[t];return!e&&i||!s&&a},GameObject:GameObject,Sprite:t=>SpriteComponent({...t,spr:this.sandbox.spr,camera:this.camera}),CollisionBox:t=>CollisionBoxComponent({...t,box_collide:this.sandbox.collide_box}),AnimationPlayer:t=>AnimationPlayerComponent(t),addObject:t=>this.addObject(t)},this.setupInput(),this.loadGame()}drawCamera(t,e,i=1){this.camera.x=t,this.camera.y=e,this.camera.scale=i,this.renderer.drawTilemap(0,0,t,e,128,128,i)}addObject(t){return t.parser=this,this.sceneObjects.push(t),t}setupInput(){let t={ArrowLeft:0,ArrowRight:1,ArrowUp:2,ArrowDown:3,z:4,x:5,Enter:6,Shift:7,a:0,d:1,w:2,s:3};t={...t,...this.inputMap.keyboard},this.gamepadMap=this.inputMap.gamepad;const e=Math.max(...Object.values(t));this.inputState=new Array(e+1).fill(!1),this.keyboardState=new Array(e+1).fill(!1),this.keyboardPreviousState=new Array(e+1).fill(!1),this.gamepadState=new Array(e+1).fill(!1),this.gamepadMapPrevious=new Array(e+1).fill(!1),window.addEventListener("keydown",e=>{void 0!==t[e.key]&&(this.keyboardState[t[e.key]]=!0)}),window.addEventListener("keyup",e=>{void 0!==t[e.key]&&(this.keyboardState[t[e.key]]=!1)})}pollGamepadInput(){const t=navigator.getGamepads?.();if(!t)return;const e=t[0];if(!e)return;for(const[t,i]of Object.entries(this.gamepadMap.buttons)){const s=parseInt(t);this.gamepadState[i]=e.buttons[s]?.pressed||!1}for(const[t,i]of Object.entries(this.gamepadMap.axes)){const s=t.match(/^(\d+)([+-])$/);if(!s)continue;const a=parseInt(s[1]),r=s[2],n=e.axes[a]??0,h="+"===r&&n>.5||"-"===r&&n<-.5;this.gamepadState[i]=this.gamepadState[i]||h}}loadGame(){try{const t=new Function("sandbox",`\n                with (sandbox) {\n                    ${this.userCode} // Exekvera användarkod\n\n                    const result = {};\n                    if (typeof _init === "function") result._init = _init;\n                    if (typeof _update === "function") result._update = _update;\n                    if (typeof _draw === "function") result._draw = _draw;\n\n                    // Spara alla variabler i sandboxen\n                    for (let key in this) {\n                        if (!(key in sandbox)) {\n                            sandbox[key] = this[key];\n                        }\n                    }\n\n                    return result;\n                }\n            `).call(this.sandbox,this.sandbox);"function"==typeof t._init&&(this.gameFunctions._init=t._init),"function"==typeof t._update&&(this.gameFunctions._update=t._update),"function"==typeof t._draw&&(this.gameFunctions._draw=t._draw)}catch(t){console.error("Error parsing game code:",t)}}async runInit(){this.setupInput(),this.gameFunctions._init(),this.renderer.clearScreen()}updateGame(){const t=performance.now(),e=t-this.lastTime;for(this.lastTime=t,this.fpsAccumulator+=e;this.fpsAccumulator>=this.fixedDelta;){this.fpsAccumulator-=this.fixedDelta,this.pollGamepadInput(),this.gameFunctions._update(this.fixedDelta/1e3);for(const t of this.sceneObjects)t.isActive&&t.update(this.fixedDelta/1e3);this.keyboardPrevState=[...this.keyboardState],this.gamepadPrevState=[...this.gamepadState]}this.alpha=this.fpsAccumulator/this.fixedDelta}drawGame(){this.renderer.clearScreen(),this.gameFunctions._draw(this.alpha);for(const t of this.sceneObjects)t.isActive&&t.draw(this.alpha)}}const SpriteComponent=({id:t,scale:e=1,flipX:i=!1,flipY:s=!1,spr:a,camera:r})=>({type:"sprite",attach(a){this.owner=a,this.id=t,this.scale=e,this.flipX=i,this.flipY=s,this.active=!0},draw(t){if(!this.active)return;const e=this.owner,i=e.scale*this.scale,s=r;let n=Array.isArray(this.id[0])?this.id:[Array.isArray(this.id)?this.id:[this.id]];const h=n.length,o=n[0].length,l=e.x,c=e.y,p=e.x+8*o*i,d=e.y+8*h*i,u=s.x,m=s.y,f=s.x+s.width,T=s.y+s.height;if(p<u-8||l>f+8||d<m-8||c>T+8)return;const x=e.previousX+(e.x-e.previousX)*t,E=e.previousY+(e.y-e.previousY)*t;for(let t=0;t<h;t++)for(let r=0;r<o;r++){const l=this.flipY?h-1-t:t,c=this.flipX?o-1-r:r,p=n[l][c];a(p,(x+8*r*i-s.x)*s.scale,(E+8*t*i-s.y)*s.scale,e.getColor(),{scale:i*s.scale,flipX:this.flipX,flipY:this.flipY})}}}),CollisionBoxComponent=({width:t=8,height:e=8,offsetX:i=0,offsetY:s=0,box_collide:a})=>({type:"collisionBox",attach(r){this.owner=r,this.width=t,this.height=e,this.offsetX=i,this.offsetY=s,this.box_collide=a,this.isOnFloor=!1,this.isOnWallLeft=!1,this.isOnWallRight=!1,this.isOnWall=!1,this.isOnCeiling=!1},getAABB(t=this.owner.x,e=this.owner.y){return{x:t+this.offsetX,y:e+this.offsetY,w:this.width*this.owner.scale,h:this.height*this.owner.scale}},update(t){const e=this.owner,i=e.x+e.velocity.x*t,s=e.y+e.velocity.y*t,a=this.getAABB(i,e.y),r=this.getAABB(e.x,s);this.box_collide(a.x,a.y,a.w,a.h)?(e.velocity.x=0,e.x<i&&(this.isOnWallRight=!0),e.x>i&&(this.isOnWallLeft=!0)):(e.x=i,this.isOnWallLeft=!1,this.isOnWallRight=!1),this.box_collide(r.x,r.y,r.w,r.h)?(e.velocity.y=0,e.y<s&&(this.isOnFloor=!0),e.y>s&&(this.isOnCeiling=!0)):(e.y=s,this.isOnFloor=!1,this.isOnCeiling=!1)}}),AnimationPlayerComponent=({animations:t,defaultAnimation:e})=>({type:"animationPlayer",attach(i){this.owner=i,this.animations=t,this.currentAnimation=null,this.currentFrameIndex=0,this.accumulatedTime=0,e&&this.play(e)},play(t){const e=this.animations[t];e&&e!==this.currentAnimation&&(this.currentAnimation=e,this.currentFrameIndex=0,this.accumulatedTime=0)},update(t){if(!this.currentAnimation)return;const e=this.currentAnimation,i=e.repeat??!0,s=e.onEnd??null;for(this.accumulatedTime+=t*(e.speed??1);this.accumulatedTime>=1;)this.accumulatedTime-=1,this.currentFrameIndex++,this.currentFrameIndex>=e.frames.length&&(i?this.currentFrameIndex=0:(this.currentFrameIndex=e.frames.length-1,s&&s(this.owner)));const a=this.owner.sprite;a&&(a.id=e.frames[this.currentFrameIndex])}});class CollisionHelper{constructor(t,e=null,i,s=2){this.map=t,this.scale=i,this.tileSize=e??8*i,this.mask=255&s}setMask(t){this.mask=255&t}_flagsAt(t,e,i=null){const s=(i||this.map)[e];if(!s)return 0;return 255&s[t]}_tileHitsMask(t,e,i,s=null){return 0!==(this._flagsAt(t,e,s)&i)}isSolidTile(t,e,i=this.map,s=this.mask){return this._tileHitsMask(t,e,s,i)}isPointSolid(t,e,i=this.map,s=this.mask){t*=this.scale,e*=this.scale;const a=Math.floor(t/this.tileSize),r=Math.floor(e/this.tileSize);return this._tileHitsMask(a,r,s,i)}isCircleColliding(t,e,i,s=this.map,a=this.mask){t*=this.scale,e*=this.scale,i*=this.scale;const r=this.tileSize,n=Math.floor((t-i)/r),h=Math.floor((t+i-1)/r),o=Math.floor((e-i)/r),l=Math.floor((e+i-1)/r);for(let c=o;c<=l;c++)for(let o=n;o<=h;o++){if(!this._tileHitsMask(o,c,a,s))continue;const n=o*r,h=c*r;if(this.circleVsRect(t,e,i,n,h,r,r))return!0}return!1}isBoxColliding(t,e,i,s,a={}){const r=a.map||this.map,n=a.mask||this.mask;t*=this.scale,e*=this.scale,i*=this.scale,s*=this.scale;const h=this.tileSize,o=Math.floor(t/h),l=Math.floor((t+i-1)/h),c=Math.floor(e/h),p=Math.floor((e+s-1)/h);for(let t=c;t<=p;t++)for(let e=o;e<=l;e++)if(this._tileHitsMask(e,t,n,r))return!0;return!1}checkHalfTile(t,e,i,s,a,r,n=this.map){t*=this.scale,e*=this.scale,i*=this.scale,s*=this.scale;const h=this.tileSize,o=Math.floor(t/h),l=Math.floor((t+i-1)/h),c=Math.floor(e/h),p=Math.floor((e+s-1)/h);for(let d=c;d<=p;d++)for(let c=o;c<=l;c++){if(!(this._flagsAt(c,d,n)&a))continue;const o=c*h,l=d*h;switch(r){case"left":if(t<o+h/2&&t+i>o)return!0;break;case"right":if(t+i>o+h/2&&t<o+h)return!0;break;case"top":if(e<l+h/2&&e+s>l)return!0;break;case"bottom":if(e+s>l+h/2&&e<l+h)return!0}}return!1}circleVsRect(t,e,i,s,a,r,n){const h=t-Math.max(s,Math.min(t,s+r)),o=e-Math.max(a,Math.min(e,a+n));return h*h+o*o<i*i}aabbOverlap(t,e,i,s,a,r,n,h){return t<a+n&&t+i>a&&e<r+h&&e+s>r}}class GameObject{constructor({x:t=0,y:e=0,scale:i=1,z:s=0,name:a=""}={}){this.x=t,this.y=e,this.previousX=t,this.previousY=e,this.scale=i,this.z=s,this.velocity={x:0,y:0},this.name=a,this.isActive=!0,this.components=[]}add(t){return t.attach?.(this),this.components.push(t),t.type&&(this[t.type]=t),this}update(t){this.previousX=this.x,this.previousY=this.y;for(const e of this.components)e.update?.(t)}destroy(){if(this.isActive=!1,this.parser){const t=this.parser.sceneObjects.indexOf(this);t>=0&&this.parser.sceneObjects.splice(t,1)}}draw(t){for(const e of this.components)e.draw?.(t)}}class RunTime{constructor(t,e,i,s,a,r,n={}){this.canvasWidth=t,this.canvasHeight=e,this.id=i,this.parentId=s,this.spriteSheet=a,this.tileMap=r,this.styles=n,this.canvas=null,this.parser=null,this.renderer=null}setRenderer(t){this.renderer=t}setParser(t){this.parser=t}createCanvas(){return this.canvas=document.createElement("canvas"),this.canvas.id=this.id,this.canvas.width=this.canvasWidth,this.canvas.height=this.canvasHeight,this.canvas.style.imageRendering="pixelated",this.canvas.style.imageRendering="crisp-edges",this.canvas.style.position="absolute",this.styles.left&&(this.canvas.style.left=this.styles.left),this.styles.top&&(this.canvas.style.top=this.styles.top),this.styles.zIndex&&(this.canvas.style.zIndex=this.styles.zIndex),this.canvas}init(){document.getElementById(this.parentId||document.body).appendChild(this.canvas),this.renderer.loadSpriteDataToTexture(this.spriteSheet),this.renderer.loadTilemapDataToTexture(this.tileMap),this.parser.runInit(),this.updateInterval=setInterval(()=>{this.parser.updateGame()},1e3/60),this.animationFrame=requestAnimationFrame(this.renderLoop.bind(this))}tearDown(){clearInterval(this.updateInterval),cancelAnimationFrame(this.animationFrame),this.renderer=null,this.parser=null}renderLoop(){this.parser.drawGame(),this.renderer.render(),this.animationFrame=requestAnimationFrame(this.renderLoop.bind(this))}}const unpack=t=>Uint8Array.from(atob(t),t=>t.charCodeAt(0));function unpackCharBitmaps(t,e){const i={};return t.forEach((t,s)=>{i[t]=e[s]}),i}function unflatten3D(t,e,i,s){const a=[];let r=0;for(let n=0;n<e;n++){const e=[];for(let a=0;a<i;a++){const i=[];for(let e=0;e<s;e++)i.push(t[r++]);e.push(i)}a.push(e)}return a}function unflatten2D(t,e,i){const s=[];for(let a=0;a<e;a++)s.push(t.slice(a*i,(a+1)*i));return s}gameData.sprites=unflatten3D(unpack(gameData.sprites),128,8,8),gameData.tilemap=unflatten2D(unpack(gameData.tilemap),64,128),gameData.collision=unflatten2D(unpack(gameData.collision),64,128),gameData.charBitmapsData=unflatten3D(unpack(gameData.charBitmapsData),46,8,8),gameData.charBitmaps=unpackCharBitmaps(gameData.charMap,gameData.charBitmapsData),gameData.inputMap=gameData.inputMap;const{SPRITE_SIZE:SPRITE_SIZE,SCALE:SCALE,NUMBER_OF_COLS:NUMBER_OF_COLS}=gameData.constants,SPRITE_TRUE_SIZE=SPRITE_SIZE*SCALE,CANVAS_WIDTH=SPRITE_TRUE_SIZE*NUMBER_OF_COLS,runtime=new RunTime(CANVAS_WIDTH,CANVAS_WIDTH,"game-canvas","app",gameData.sprites,gameData.tilemap),canvas=runtime.createCanvas(),renderer=new Renderer(canvas,gameData.palette,gameData.charBitmaps,SPRITE_SIZE,NUMBER_OF_COLS,SCALE,gameData.tilemap),parser=new GameParser(gameData.code,renderer,gameData.palette,SCALE,SPRITE_TRUE_SIZE,gameData.inputMap,gameData.collision);function scaleCanvasToFit(){const t=document.getElementById("app"),e=document.getElementById("game-canvas"),i=CANVAS_WIDTH/SCALE,s=Math.floor(Math.min(t.clientWidth/i,t.clientHeight/i));e.style.width=i*s+"px",e.style.height=i*s+"px"}runtime.setRenderer(renderer),runtime.setParser(parser),runtime.init(),scaleCanvasToFit(),window.addEventListener("resize",scaleCanvasToFit),window.addEventListener("DOMContentLoaded",scaleCanvasToFit);